#include "AES.hpp"
void print_word(const word& w) {
    std::uint32_t value = 0;
    for (std::size_t i = 0; i < w.size(); ++i) {
        value = (value << 8) | w[i];
    }
    std::cout << std::hex << std::setw(8) << std::setfill('0') << value << std::endl;
}
void print_byte(const byte& b){
  std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)b << std::endl;
}
std::string printHex(const std::array<uint8_t, 4 * 4>& input) {
    std::ostringstream oss;
    for (const auto& byte : input) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return oss.str();
}
std::string printHex2(std::array<word, Nb*(Nr+1)>::const_iterator s) {
    std::ostringstream oss;
    for (int i = 0; i < 4; ++i) { for (const auto& byte : *s) {
            oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
        }
        ++s;
    }
    return oss.str();
}

void test_KeyExpansion(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
                                 0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<word,Nb*(Nr+1)> expected_w = {
    word{0x2b,0x7e,0x15,0x16},
    word{0x28,0xae,0xd2,0xa6},
    word{0xab,0xf7,0x15,0x88},
    word{0x09,0xcf,0x4f,0x3c},
    word{0xa0,0xfa,0xfe,0x17},
    word{0x88,0x54,0x2c,0xb1},
    word{0x23,0xa3,0x39,0x39},
    word{0x2a,0x6c,0x76,0x05},
    word{0xf2,0xc2,0x95,0xf2},
    word{0x7a,0x96,0xb9,0x43},
    word{0x59,0x35,0x80,0x7a},
    word{0x73,0x59,0xf6,0x7f},
    word{0x3d,0x80,0x47,0x7d},
    word{0x47,0x16,0xfe,0x3e},
    word{0x1e,0x23,0x7e,0x44},
    word{0x6d,0x7a,0x88,0x3b},
    word{0xef,0x44,0xa5,0x41},
    word{0xa8,0x52,0x5b,0x7f},
    word{0xb6,0x71,0x25,0x3b},
    word{0xdb,0x0b,0xad,0x00},
    word{0xd4,0xd1,0xc6,0xf8},
    word{0x7c,0x83,0x9d,0x87},
    word{0xca,0xf2,0xb8,0xbc},
    word{0x11,0xf9,0x15,0xbc},
    word{0x6d,0x88,0xa3,0x7a},
    word{0x11,0x0b,0x3e,0xfd},
    word{0xdb,0xf9,0x86,0x41},
    word{0xca,0x00,0x93,0xfd},
    word{0x4e,0x54,0xf7,0x0e},
    word{0x5f,0x5f,0xc9,0xf3},
    word{0x84,0xa6,0x4f,0xb2},
    word{0x4e,0xa6,0xdc,0x4f},
    word{0xea,0xd2,0x73,0x21},
    word{0xb5,0x8d,0xba,0xd2},
    word{0x31,0x2b,0xf5,0x60},
    word{0x7f,0x8d,0x29,0x2f},
    word{0xac,0x77,0x66,0xf3},
    word{0x19,0xfa,0xdc,0x21},
    word{0x28,0xd1,0x29,0x41},
    word{0x57,0x5c,0x00,0x6e},
    word{0xd0,0x14,0xf9,0xa8},
    word{0xc9,0xee,0x25,0x89},
    word{0xe1,0x3f,0x0c,0xc8},
    word{0xb6,0x63,0x0c,0xa6}
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  assert(expected_w == w);
  std::cerr<<"OK KeyExpansion"<<std::endl;
}
void test_AddRoundKey(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<byte,4*Nb> input = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  AddRoundKey(input,w.cbegin());
  std::cerr<<"OK AddRoundKey"<<std::endl;
}
void test_SubBytes(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<byte,4*Nb> input = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  std::array<word,Nb*(Nr+1)> w;
  const std::array<byte,4*Nb> expected_reslt = {
    0xd4,0x27,0x11,0xae,
    0xe0,0xbf,0x98,0xf1,
    0xb8,0xb4,0x5d,0xe5,
    0x1e,0x41,0x52,0x30
  };
  KeyExpansion(key,w);
  AddRoundKey(input,w.cbegin());
  SubBytes(input);
  assert(input == expected_reslt);
  std::cerr<<"OK SubBytes"<<std::endl;
}
void test_InvSubBytes(){
  std::array<byte,4*Nb> input= {
    0xe9,0x09,0x89,0x72,
    0xcb,0x31,0x07,0x5f,
    0x3d,0x32,0x7d,0x94,
    0xaf,0x2e,0x2c,0xb5
  };
  const std::array<byte,4*Nb> expected_reslt= {
    0xeb,0x40,0xf2,0x1e,
    0x59,0x2e,0x38,0x84,
    0x8b,0xa1,0x13,0xe7,
    0x1b,0xc3,0x42,0xd2
  };
  InvSubBytes(input);
  assert(input==expected_reslt);
  std::cerr<<"OK InvSubBytes"<<std::endl;
}
void test_ShiftRows(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<byte,4*Nb> input = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  const std::array<byte,4*Nb> expected_reslt = {
    0xd4,0xbf,0x5d,0x30,
    0xe0,0xb4,0x52,0xae,
    0xb8,0x41,0x11,0xf1,
    0x1e,0x27,0x98,0xe5
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  AddRoundKey(input,w.cbegin());
  SubBytes(input);
  ShiftRows(input);
  assert(expected_reslt == input);
  std::cerr<<"OK ShiftRows"<<std::endl;
}
void test_InvShiftRows(){
 std::array<byte,4*Nb> input = {
    0x39,0x25,0x84,0x1d,
    0x02,0xdc,0x09,0xfb,
    0xdc,0x11,0x85,0x97,
    0x19,0x6a,0x0b,0x32
  };
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  const std::array<byte,4*Nb> expected_reslt_AddRound = {
    0xe9,0x31,0x7d,0xb5,
    0xcb,0x32,0x2c,0x72,
    0x3d,0x2e,0x89,0x5f,
    0xaf,0x09,0x07,0x94
  };
  const std::array<byte,4*Nb> expected_reslt_InvShiftRows= {
    0xe9,0x09,0x89,0x72,
    0xcb,0x31,0x07,0x5f,
    0x3d,0x32,0x7d,0x94,
    0xaf,0x2e,0x2c,0xb5
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  AddRoundKey(input,next(w.begin(),Nr*Nb));
  assert(input==expected_reslt_AddRound);
  InvShiftRows(input);
  assert(input==expected_reslt_InvShiftRows);
  std::cerr<<"OK InvShiftRows"<<std::endl;
}
void test_xtime(){
  assert(xtime(0x57)==0xae);
  assert(xtime(0xae)==0x47);
  assert(xtime(0x47)==0x8e);
  assert(xtime(0x8e)==0x07);
  std::cerr<<"OK xtime"<<std::endl;
}
void test_modmul(){
  assert(modmul(0x57,0x13)==0xfe);
  assert(modmul(0x57,0x10)==0x07);
  assert(modmul(0x13,0x57)==0xfe);
  assert(modmul(0x10,0x57)==0x07);
  std::cerr<<"OK modmul"<<std::endl;
}
void test_MixColumns(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<byte,4*Nb> input = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  const std::array<byte,4*Nb> expected_reslt = {
    0x04,0x66,0x81,0xe5,
    0xe0,0xcb,0x19,0x9a,
    0x48,0xf8,0xd3,0x7a,
    0x28,0x06,0x26,0x4c
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  AddRoundKey(input,w.cbegin());
  SubBytes(input);
  ShiftRows(input);
  MixColumns(input);
  assert(expected_reslt == input);
  std::cerr<<"OK MixColumns"<<std::endl;
}
void test_InvMixColumns(){
 std::array<byte,4*Nb> input = {
    0x39,0x25,0x84,0x1d,
    0x02,0xdc,0x09,0xfb,
    0xdc,0x11,0x85,0x97,
    0x19,0x6a,0x0b,0x32
  };
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  const std::array<byte,4*Nb> expected_reslt= {
    0x87,0x6e,0x46,0xa6,
    0xf2,0x4c,0xe7,0x8c,
    0x4d,0x90,0x4a,0xd8,
    0x97,0xec,0xc3,0x95
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  AddRoundKey(input,next(w.begin(),Nr*Nb));
  InvShiftRows(input);
  InvSubBytes(input);
  AddRoundKey(input,next(w.begin(),(Nr-1)*Nb));
  InvMixColumns(input);
  assert(input==expected_reslt);
  std::cerr<<"OK InvMixColumns"<<std::endl;
}
void test_Cipher(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  std::array<byte,4*Nb> input = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  const std::array<byte,4*Nb> expected_reslt = {
    0x39,0x25,0x84,0x1d,
    0x02,0xdc,0x09,0xfb,
    0xdc,0x11,0x85,0x97,
    0x19,0x6a,0x0b,0x32
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  std::array<byte,4*Nb> out;
  Cipher(input,out,w);
  assert(out == expected_reslt);
  std::cerr<<"OK Cipher"<<std::endl;
}
void test_InvCIpher(){
  std::array<byte,4*Nb> key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,
    0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; 
  const std::array<byte,4*Nb> expected_reslt = {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,
    0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  std::array<byte,4*Nb> input = {
    0x39,0x25,0x84,0x1d,
    0x02,0xdc,0x09,0xfb,
    0xdc,0x11,0x85,0x97,
    0x19,0x6a,0x0b,0x32
  };
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  std::array<byte,4*Nb> out;
  InvCipher(input,out,w);
  assert(out == expected_reslt);
  std::cerr<<"OK InvCipher"<<std::endl;
}
void test(){
  std::array<byte,4*Nb> input = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,
    0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff}; 
  std::array<byte,4*Nb> key = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,
    0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f}; 
  std::array<word,Nb*(Nr+1)> w;
  KeyExpansion(key,w);
  std::cout<<"round[ 0].input "<<printHex(input)<<std::endl;
  AddRoundKey(input,w.begin());
  std::cout<<"round[ 0].k_sch "<<printHex2(w.begin())<<std::endl;
  for(std::size_t round = 1;round <= Nr-1;round++){
    std::cout<<"round[ "<<round<<"].start "<<printHex(input)<<std::endl;
    SubBytes(input);
    std::cout<<"round[ "<<round<<"].s_box "<<printHex(input)<<std::endl;
    ShiftRows(input);
    std::cout<<"round[ "<<round<<"].s_row "<<printHex(input)<<std::endl;
    MixColumns(input);
    std::cout<<"round[ "<<round<<"].m_col "<<printHex(input)<<std::endl;
    std::cout<<"round[ "<<round<<"].k_sch "<<printHex2(next(w.begin(),round*Nb))<<std::endl;
    AddRoundKey(input,next(w.begin(),round*Nb));
  }
  std::cout<<"round["<<Nr<<"].start "<<printHex(input)<<std::endl;
  SubBytes(input);
  std::cout<<"round["<<Nr<<"].s_box "<<printHex(input)<<std::endl;
  ShiftRows(input);
  std::cout<<"round["<<Nr<<"].s_row "<<printHex(input)<<std::endl;
  AddRoundKey(input,next(w.begin(),Nr*Nb));
    std::cout<<"round["<<Nr<<"].k_sch "<<printHex2(next(w.begin(),Nr*Nb))<<std::endl;
  std::cout<<"round["<<Nr<<"].output "<<printHex(input)<<std::endl;
  std::cout<<"round[ 0].iinput "<<printHex(input)<<std::endl;
  std::cout<<"round[ 0].ik_sch "<<printHex2(next(w.begin(),Nr*Nb))<<std::endl;
  AddRoundKey(input,next(w.begin(),Nr*Nb));
  for(std::size_t round = Nr-1;round>=1;round--){
    std::cout<<"round[ "<<Nr-round<<"].istart "<<printHex(input)<<std::endl;
    InvShiftRows(input);
    std::cout<<"round[ "<<Nr-round<<"].is_row "<<printHex(input)<<std::endl;
    InvSubBytes(input);
    std::cout<<"round[ "<<Nr-round<<"].is_box "<<printHex(input)<<std::endl;
    std::cout<<"round[ "<<Nr-round<<"].ik_sch "<<printHex2(next(w.begin(),round*Nb))<<std::endl;
    AddRoundKey(input,next(w.begin(),round*Nb));
    std::cout<<"round[ "<<Nr-round<<"].ik_add "<<printHex(input)<<std::endl;
    InvMixColumns(input);
  }
  std::cout<<"round["<<Nr<<"].istart "<<printHex(input)<<std::endl;
  InvShiftRows(input);
  std::cout<<"round["<<Nr<<"].is_row "<<printHex(input)<<std::endl;
  InvSubBytes(input);
  std::cout<<"round["<<Nr<<"].is_box "<<printHex(input)<<std::endl;
  std::cout<<"round["<<Nr<<"].ik_sch "<<printHex2(w.begin())<<std::endl;
  AddRoundKey(input,w.begin());
  std::cout<<"round["<<Nr<<"].ioutput "<<printHex(input)<<std::endl;
}
int main(int argc, char** argv){
  test_KeyExpansion();
  test_AddRoundKey();
  test_SubBytes();
  test_ShiftRows();
  test_xtime();
  test_modmul();
  test_MixColumns();
  test_Cipher();
  test_InvShiftRows();
  test_InvSubBytes();
  test_InvMixColumns();
  test_InvCIpher();
  test();
}
